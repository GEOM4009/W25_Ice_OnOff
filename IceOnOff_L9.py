# -*- coding: utf-8 -*-
"""IceOnOff_L9_Trial.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1rv8JWR90dIr7uelULQjfZIPyZHs6yAFk
"""

import ee
import pandas as pd
import datetime
import argparse
import webbrowser
import matplotlib.pyplot as plt


def gee_initialize():
    """
    Author: Ben Schellenberg

    Authenticates the user's Google account and initializes their Google Earth Engine project.

    The user will be prompted to enter their Google Earth Engine project (e.g. ee-username).
    If a valid project is not found, the user can either enter a new project name, or exit the program.

    Note, this function is designed to be executed at the command line. Otherwise, 'project' would be a direct parameter.

    Returns
    -------
    None.

    This function does not return a value. Rather, it sets up access to Google Earth Engine.

    """

    ee.Authenticate()
    # Authenticating once, outside of the while loop.
    # In GEE, authentication happens before initialization and doesn't require a project name.

    while True:
        # A continuous loop, only broken by 'return', 'exit()', or 'break'.
        # Allows the function to continue until a specific case (input) breaks it.
        # Source: https://stackoverflow.com/questions/3754620/what-does-while-true-mean-in-python

        project = input("\nEnter the name of your Google Earth Engine Project: ")
        try:
            ee.Initialize(project=project)
            print("\nInitialization Successful!")
            break
        except Exception:
            print("Failed to initialize Earth Engine with that project.")

            while True:
                # If initialization fails, the user can keep trying to re-enter a new project name.

                try_again = (
                    input(
                        "\nWould you like to try a different project name? (yes/no): "
                    )
                    .strip()
                    .lower()
                )

                if try_again in ["yes", "y"]:
                    break  # Back to input (i.e. outer loop)

                elif try_again in ["no", "n"]:
                    print("Ok. Exiting the program.")
                    exit()  # Quit program entirely
                else:
                    print(
                        "Please enter either 'yes' or 'no'."
                    )  # Handling invalid answer.


def get_lake(lake_id):
    """
    Authors: Ben Schellenberg, Caitlin McMann

    Selects a waterbody from "projects/ee-benschellenberg04/assets/ORW_WaterBodies" (Google Earth Engine asset) based on a unique HYDROUID.

    The selected waterbody is buffered 50 metres inwards to reduce edge-pixel contamination.

    The buffered waterbody is then projected to WGS 84 / UTM Zone 18N (EPSG: 32618), which covers 78°W to 72°W longitude.

    Parameters
    ----------
    lake_id : int
        The HYDROUID of the waterbody from "OWR_waterbodies" that the user would like to select.

        IMPORTANT: Input ID cannot contain commas. (e.g. 55,404 --> 55404)

    Returns
    -------
    final_lake : ee.FeatureCollection
        The selected waterbody, buffered and reprojected.

    """

    ORW_waterbodies = ee.FeatureCollection(
        "projects/ee-benschellenberg04/assets/ORW_WaterBodies"
    )

    lake = ORW_waterbodies.filter(ee.Filter.eq("HYDROUID", lake_id))  # Selecting ID
    if lake.size().getInfo() == 0:
        return None

    buff_lake = lake.map(lambda feature: feature.buffer(-50))  # Buffering waterbody

    final_lake = buff_lake.map(
        lambda feature: feature.setGeometry(
            feature.geometry().transform(
                ee.Projection("EPSG:32618"), maxError=1
            )  # Reprojection
        )
    )

    return final_lake


def validate_lake():
    """
    Author: Ben Schellenberg, Hao Fan

    This function is designed to be executed at the command line and handles the case where no AOI is found in the main() function (i.e. invalid HYDROUID).

    The user will be prompted to open a reference map showing the IDs of the waterbodies, followed by a prompt to enter an ID.

    If a valid ID is entered, 'get_lake()' will be called to define an AOI. If not, the user can either enter a new ID, or exit the program.

    Returns
    -------
    aoi : ee.FeatureCollection
        The output of 'get_lake()' if a valid HYDROUID is entered.

    lake_id : int
        The unique HYDROUID of the selected lake.

    """
    while True:
        # Outer loop that will continue until the user either finds a valid AOI or exits the program.

        while True:
            # Inner loop to handle whether or not the user wants to open the map.
            open_map = (
                input(
                    "\nYou'll need the HYDROUID of the waterbody you'd like to analyze. Would you like to open a reference map showing all waterbodies and their IDs? (yes/no): "
                )  # Prompting reference map
                .strip()
                .lower()
            )
            if open_map in ["yes", "y"]:
                webbrowser.open(
                    "https://ben-schellenberg.github.io/OttawaRiverWatershed/ORW_Feature_Names.html"
                )  # If user enters 'yes', the map will open in their browser
                break  # Back to outer loop (ID entry)

            elif open_map in ["no", "n"]:
                break  # If user enters 'no', they will continue to ID entry (outer loop).

            else:
                print("Please enter either 'yes' or 'no'.")  # Handling invalid answer.

        try:
            lake_id = int(
                input(
                    "\nEnter the HYDROUID of the lake you would like to analyze (ID cannot include commas): "
                )
            )  # Command line inputs are strings but the HYDROUIDs are integers.
            aoi = get_lake(lake_id)  # Try get_lake() with the entered ID

            if aoi:
                return aoi, lake_id  # AOI found -> Exits the loop
            else:
                print(
                    "Lake not found."
                )  # AOI not found -> User will be prompted to try again.

        except ValueError:
            print("Invalid HYDROUID.")
        # This excpetion will occur if the entered ID is non-numeric and can't be converted to int.

        while True:
            try_again = (
                input("\nWould you like to try again? (yes/no): ").strip().lower()
            )

            if try_again in ["yes", "y"]:
                break  # Back to outer loop (i.e. map prompt and ID entry)

            elif try_again in ["no", "n"]:
                print("Ok. Exiting the program.")
                exit()  # If user decides to quite program entirely.

            else:
                print("Please enter either 'yes' or 'no'.")  # Handling invalid answer.

    # Note, the structure of the interaction between this function and the main() function (i.e. if not aoi ...) was AI-derived.


def aoi_CloudCover_L9(image, aoi):
    """
    Authors: Derek Mueller, Ben Schellenberg

    Calculates the percentage of cloud and cloud shadow pixels within a given AOI for a Landsat 9 image.
    This percentage is added to a new image property called "AOI_CLOUD_COVER".

    Parameters
    ----------
    image : ee.Image
        Image for which cloud cover over a given AOI will be calculated.

    aoi : ee.FeatureCollection or ee.Feature
        The AOI over which cloud cover will be calculated.

    Returns
    -------
    ee.Image
        The same image with a new property called "AOI_CLOUD_COVER".
        This property contains the percentage of cloudy pixels (including cloud shadow) within the given AOI.

    """
    # Get cloud mask (1 for clouds, 0 for non-clouds) .gt(0) converts to binary
    clouds = image.select("QA_PIXEL").bitwiseAnd(1 << 3).gt(0)
    cloud_shadow = image.select("QA_PIXEL").bitwiseAnd(1 << 4).gt(0)
    # Added cloud shadow here.

    combined = clouds.Or(cloud_shadow)
    # Considering both binary layers (clouds and shadows).

    # Count total pixels and cloudy pixels
    stats = combined.reduceRegion(
        reducer=ee.Reducer.count().combine(ee.Reducer.sum(), "", True),
        geometry=aoi,
        scale=30,
        maxPixels=1e9,
    )

    # Calculate percentage
    cloud_percent = (
        ee.Number(
            stats.get("QA_PIXEL_sum")
        )  # Sum only considers cloudy pixels (i.e. Equal to 1 in binary layer)
        .divide(
            stats.get("QA_PIXEL_count")
        )  # Total pixel count (i.e. 1 or 0 in the binary layer)
        .multiply(100)
    )

    return image.set("AOI_CLOUD_COVER", cloud_percent)

    # Note: This function was provided by Derek, and slightly modified to include cloud shadows 'stats'.


def L9_CloudMask(image):
    """
    Author: Ben Schellenberg

    Removes cloud pixels (including dialated clouds) and cloud shadow pixels from a Landsat 9 image.

    Parameters
    ----------
    image : ee.Image
        Image for which clouds and cloud shodows will be masked out.

    Returns
    -------
    Updated image : ee.Image
        Same image without any clouds (inclulding dialated clouds) or cloud shadows.

    """
    qa = image.select("QA_PIXEL")
    dCloudBitMask = 1 << 1  # Dialated Clouds
    cloudBitMask = 1 << 3  # Cloud
    cirrusBitMask = 1 << 4  # Cloud Shadow

    mask = (
        qa.bitwiseAnd(cloudBitMask)
        .eq(0)
        .And(qa.bitwiseAnd(cirrusBitMask).eq(0))
        .And(qa.bitwiseAnd(dCloudBitMask).eq(0))
    )  # Setting all three bitmasks to 0.

    return image.updateMask(mask)


def get_imagery(aoi, start_date, end_date=None):
    """
    Authors: Ben Schellenberg, Hao Fan

    Retrieves a Google Earth Engine ImageCollection for a given AOI and date/date range.

    The image collection will be filtered to only retain images that fully cover the AOI.

    Further filtering will only retain imagery with less than 10% cloud cover over the AOI (i.e. aoi_CloudCover_L9).

    Finally, clouds and cloud shadows will be masked out of the retained images in the collection (i.e. L9_CloudMask).

    Parameters
    ----------
    aoi : ee.FeatureCollection
        (Multi)Polygon representing the waterbody of interest.

    start_date : str
        Start date for imagery collection, in 'YYYY-MM-DD' format.

    end_date : str, optional
        End date for imagery collection, in 'YYYY-MM-DD' format.
        If None (default), imagery will be collected for a single day (i.e., start_date only).

    Returns
    -------
    final_stack : ee.ImageCollection or ee.Image
        Image(s) collected between/on specified date(s) that met filtering criteria.

    """
    try:
        start = datetime.datetime.strptime(
            start_date, "%Y-%m-%d"
        )  # Parsing user-entered date (string) to a datetime object.
        start_formatted = start.strftime(
            "%Y-%m-%d"
        )  # Back to a clean 'YYYY-MM-DD' string

        if end_date is None:  # Handling single-date analyses
            end = start + datetime.timedelta(
                days=1
            )  # Adding 1 day, because GEE requires at least a 1 day window.
        else:
            end = datetime.datetime.strptime(
                end_date, "%Y-%m-%d"
            )  # Again creating the datetime object

            if end < start:
                print("\nEnd date cannot be earlier than start date.")
                return None

        end_formatted = end.strftime("%Y-%m-%d")  # And back to string

    except ValueError:
        print("\nInvalid date format. Please use the format 'YYYY-MM-DD'.")
        return None
    # This error will occur if the user does not follow the proper format.

    # Note, for datetime/string formatting, AI was used to help.

    # Load Image Collection
    L9 = (
        ee.ImageCollection("LANDSAT/LC09/C02/T1_L2")
        .filterBounds(aoi)
        .filterDate(start_formatted, end_formatted)
        .sort("system:time_start")
    )

    # Get images with full coverage
    # Full coverage is defined as having the entire geometry of the aoi within the image.
    L9_new = L9.map(
        lambda image: image.set(
            "FullCoverage", image.geometry().contains(aoi, maxError=1)
        )  # Sets a new property called "FullCoverage"
    ).filter(ee.Filter.eq("FullCoverage", True))
    # Only retains imagery where the new "FullCoverage" property evaluates to True

    L9_newer = L9_new.map(lambda image: aoi_CloudCover_L9(image, aoi)).filter(
        ee.Filter.lt("AOI_CLOUD_COVER", 10)
    )  # Applying aoi_CloudCover_L9() to all images in the collection.

    final_stack = L9_newer.map(L9_CloudMask)  # Removing clouds from all images.

    num_Image = final_stack.size().getInfo()

    if num_Image == 0:
        return None
    else:
        return final_stack


def get_IceCoverage(aoi, image_collection):
    """
    Author: Ben Schellenberg

    Calculates the ice cover percentage of a given waterbody from a Landsat 9 image or image collection.

    Ice is identified using an Normalized Difference Snow index (NDSI), and defined as areas exeecing a value of 0.4.

    The date, ice coverage, and sensor for each image are added to a pandas dataframe.

    Parameters
    ----------
    aoi : ee.FeatureCollection
        (Multi)Polygon representing the waterbody of interest.

    image_collection : ee.ImageCollection or ee.Image
        Image(s) collected between/on specified date(s) that met filtering criteria.

    Returns
    -------
    df : pandas.DataFrame
        DataFrame containing the date, ice coverage (%), and sensor (i.e. Landsat 9).

    name : str
        Name of the selected waterbody.

    first_date : str
        Date of the first image collected within specified date range.

    last_date : str
        Date of the last image collected within specified date range.

    """

    aoi_area = aoi.map(lambda feature: feature.set("area", feature.area(maxError=1)))
    # aoi is a FeatureCollection so we have to map the area to all it's features.

    total_aoi_area = aoi_area.reduceColumns(ee.Reducer.sum(), ["area"]).get("sum")
    # The sum of aoi areas provide its total area.

    Lake_Area = ee.Number(total_aoi_area).getInfo()

    # Turning the image collection into an iterable list.
    if image_collection.name() == "Image":
        image_list = ee.List([image_collection])
    else:
        image_list = image_collection.toList(image_collection.size())

    num_images = image_list.size().getInfo()

    # The next few lines define the date of the first and last image, and the name of the aoi.
    # This is useful for given the exported csv a unique and descriptive name.
    first_image = ee.Image(image_list.get(0))
    last_image = ee.Image(image_list.get(num_images - 1))

    first_date = (
        ee.Date(first_image.get("system:time_start")).format("YYYY-MM-dd").getInfo()
    )
    last_date = (
        ee.Date(last_image.get("system:time_start")).format("YYYY-MM-dd").getInfo()
    )

    if aoi.name() == "FeatureCollection":
        name = aoi.first().get("NAME").getInfo()
    else:
        name = aoi.get("NAME").getInfo()

    results = []  # Empty list -> Analysis results will be appended to this list

    for i in range(num_images):
        image = ee.Image(image_list.get(i))
        # Iterating through the image collection

        date = ee.Date(image.get("system:time_start")).format("YYYY-MM-dd").getInfo()
        # Date of individual image

        img_clip = ee.Image(image.clip(aoi))
        # Clipping individual image to aoi for ice cover analysis

        NDSI = img_clip.normalizedDifference(["SR_B3", "SR_B6"]).rename("NDSI")
        # NDSI layer for clipped image
        NDSI_mask = NDSI.gt(0.15)  # NDSI > 0.15 seems to represent ice the best

        pixel_area = NDSI_mask.multiply(ee.Image.pixelArea())
        # Because the NDSI mask is binary, multiplying it by pixel-area will only return the area of "Ice pixels" (i.e. 1)
        # Non ice pixel will yield 0*900 = 0 --> does not contribute to the sum in the next line.

        mask_area = pixel_area.reduceRegion(
            reducer=ee.Reducer.sum(), geometry=aoi.geometry(), scale=30, maxPixels=1e10
        ).get(
            "NDSI"
        )  # Total ice pixel area

        Ice_Area = ee.Number(mask_area).getInfo()

        Ice_Coverage = min(round((Ice_Area / Lake_Area) * 100, 2), 100.00)
        # Notice the min() function. In some cases, ice cover percentage exceeded 100.00 very slightly (i.e. 100.25%).
        # I suspect this is do to differences between vector and raster area calculation.
        # See figures 3 and 4 in the article below (p.429)
        # https://www.asprs.org/wp-content/uploads/pers/1997journal/apr/1997_apr_425-434.pdf

        # This issue could be avoided by converting the NDSI mask to a polygon.
        # However, given the long runtime, unnecessary conversions were minimized.

        results.append(
            {
                "Date": date,
                "Ice Coverage (%)": Ice_Coverage,
                "Sensor": image.get("SPACECRAFT_ID").getInfo(),
            }
        )  # Append a dictionary of the results to the empty list.

    # Could have something download image here given the responde to a prompt...

    df = pd.DataFrame(results)  # Convert list to a dataframe.

    print("\n", df)

    return df, name, first_date, last_date


def prompt_download(df, name, first_date, last_date):
    """
    Author: Ben Schellenberg

    Parameters
    ----------
    df : pandas.DataFrame
        DataFrame containing the date, ice coverage (%), and sensor (i.e. Landsat 9).

    name : str
        Name of the selected waterbody.

    first_date : str
        Date of the first image collected within specified date range.

    last_date : str
        Date of the last image collected within specified date range.

    Returns
    -------
    None.

    This function does not return a value. Rather, it saves a CSV to the users directory, if they so choose.

    """
    answer = (
        input("\nWould you like to download these results to a CSV? (yes/no): ")
        .strip()
        .lower()
    )
    if answer in ["yes", "y"]:
        if first_date == last_date:
            filename = f"{name}_IceCoverage_{first_date}.csv"
            # If there is only one date, the filename will only include that date.
        else:
            filename = f"{name}_IceCoverage_{first_date}_to_{last_date}.csv"
            # If there is multiple dates, the filename will include the date range.

        df.to_csv(filename, index=False)  # Saving the csv
        print(f"OK! CSV saved as '{filename}' in your current directory.")

    elif answer in ["no", "n"]:
        print("Ok! No CSV file was saved")
        # Program ends

    else:
        print("Please enter 'yes' or 'no'.")
        prompt_download(df, name, first_date, last_date)
        # Reprompt user if they enter an invalid answer.


def plot_ice_coverage(df):
    """
    Author: Caitlin McMann

    Plots ice coverage of a given AOI between specified dates.

    Parameters
    ----------
    df : pandas.DataFrame
        The DataFrame containing the ice coverage data and outlier status.

    Returns
    -------
    None
        Displays a plot showing the ice coverage over time with outliers marked in red.
    """
    df["Date"] = pd.to_datetime(df["Date"])

    plt.figure(figsize=(10, 6))

    # Plot main line first
    plt.plot(
        df["Date"],
        df["Ice Coverage (%)"],
        marker="o",
        color="b",
        label="Ice Coverage (%)",
        zorder=1,
    )

    plt.xlabel("Date")
    plt.ylabel("Ice Coverage (%)")
    plt.title("Ice Coverage Over Time")
    plt.xticks(rotation=45)
    plt.grid(True)
    plt.legend()
    plt.tight_layout()
    plt.show()


def main():
    """
    Author: Ben Schellenberg

    Orchestrates entire Ice On/Off analysis at the command line.

    This function handles user inputs, collects filtered Landsat 9 imagery, and calculates ice coverage over a given waterbody.

    Returns
    -------
    The printed results of the Ice On/Off analysis in a pandas DataFrame.
    The user will be able to download these results to a CSV in their current directory.

    """

    gee_initialize()  # Initialize Earth Engine project

    # Adding necessary arguments for the analysis
    parser = argparse.ArgumentParser()
    parser.add_argument(
        "lake_id",
        help="Enter the HYDROUID of the lake you would like to analyze. The ID cannot contain commas.",
        nargs="?",
    )
    parser.add_argument(
        "start_date", help="Enter the start date in the format 'YYYY-MM-DD'", nargs="?"
    )
    parser.add_argument(
        "--end_date",
        help="Enter the end date (optional) in the format 'YYYY-MM-DD'. Leave blank for single day: ",
    )
    args = parser.parse_args()
    # Assigning arguments to a variable that can be used as input for the functions.

    if args.lake_id:
        try:
            lake_id = int(args.lake_id)
            aoi = get_lake(lake_id)
            if not aoi:
                aoi, lake_id = validate_lake()
        except ValueError:
            print("Invalid HYDROUID.")
            aoi, lake_id = validate_lake()
    else:
        aoi, lake_id = validate_lake()

    start_date = args.start_date
    end_date = args.end_date

    if not start_date:
        start_date = input("\nEnter the start date in the format 'YYYY-MM-DD': ")

    if not end_date:
        end_date_input = input(
            "Enter the end date (optional) in the format 'YYYY-MM-DD'. Leave blank for single day: "
        ).strip()
        end_date = end_date_input if end_date_input else None

    # This loop handles the  case where no imagery is found.
    # The user will be prompted to enter a new date range.
    # For future improvements, handling this case outside of the main() function would be cleaner.
    # Including this loop in the get_imagery() function would be appropriate.
    image_stack = None
    while image_stack is None:
        image_stack = get_imagery(aoi, start_date, end_date)
        if image_stack is None:
            print("\nNo imagery found for this date range.")

            while True:  # Same 'while True' loop logic as above
                try_again = (
                    input("\nWould you like to enter a new date range? (yes/no): ")
                    .strip()
                    .lower()
                )
                if try_again in ["yes", "y"]:
                    break  # Reprompt date entry

                elif try_again in ["no", "n"]:
                    print("Ok. Exiting the program.")
                    return  # Exit the program

                else:
                    print("Please enter either 'yes' or 'no'.")

            start_date = input("\nEnter the start date (YYYY-MM-DD): ")
            end_date = input(
                "Enter the end date (optional, YYYY-MM-DD). Leave blank for single day: "
            )
            if end_date.strip() == "":
                end_date = None

    df, name, first_date, last_date = get_IceCoverage(aoi, image_stack)

    plot_ice_coverage(df)

    prompt_download(df, name, first_date, last_date)


if __name__ == "__main__":
    main()
